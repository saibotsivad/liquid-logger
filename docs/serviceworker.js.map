{"version":3,"file":"serviceworker.js","sources":["../src/node_modules/app/serviceworker.js"],"sourcesContent":["/*\n\nThe service-worker.json file is generated as a final step\nof building the webapp. It should contain a list of all\nbuilt files (e.g. JS/CSS) and all static assets, such as\nthe logo images and global CSS file.\n\nThis file is heavily inspired by the SvelteJS version:\n\nhttps://github.com/sveltejs/svelte/blob/master/site/src/service-worker.js\n\n*/\nimport { cacheableFiles, cacheName, prefetchCacheableUrls } from '../../../public/serviceworker-lists.json'\n\nconst cachedFiles = new Set(cacheableFiles)\n\nself.addEventListener('install', event => {\n\tevent.waitUntil(\n\t\tcaches\n\t\t\t.open(cacheName)\n\t\t\t.then(cache => {\n\t\t\t\tconst promises = prefetchCacheableUrls.map(async urlToPrefetch => {\n\t\t\t\t\tconst url = new URL(urlToPrefetch)\n\t\t\t\t\t// Note: If prefetching during the `install` event, if\n\t\t\t\t\t// you need to prefetch a URL that is on a host that\n\t\t\t\t\t// does not use CORS, you will need to do like so:\n\t\t\t\t\t//\n\t\t\t\t\t//     const request = new Request(url, { mode: 'no-cors' })\n\t\t\t\t\t//\n\t\t\t\t\t// However, the problem with no-cors mode is that\n\t\t\t\t\t// all responses from cross-origin hosts will be\n\t\t\t\t\t// opaque--you won't know why the failure occurred.\n\t\t\t\t\t// See: https://github.com/whatwg/fetch/issues/14\n\t\t\t\t\tconst request = new Request(url, { mode: 'no-cors' })\n\t\t\t\t\tconst response = await fetch(request)\n\n\t\t\t\t\t// NOTE: You should probably handle response errors\n\t\t\t\t\t// here. If I come up with a good use case and example,\n\t\t\t\t\t// I'll add it here, but I don't have one yet.\n\n\t\t\t\t\treturn cache.put(urlToPrefetch, response)\n\t\t\t\t})\n\t\t\t\treturn Promise.all([\n\t\t\t\t\tcache.addAll(cacheableFiles),\n\t\t\t\t\t...promises\n\t\t\t\t])\n\t\t\t})\n\t\t\t.then(() => {\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting\n\t\t\t\tself.skipWaiting()\n\t\t\t})\n\t)\n})\n\nself.addEventListener('activate', event => {\n\tevent.waitUntil(\n\t\tcaches.keys().then(async keys => {\n\t\t\t// delete all old caches\n\t\t\tfor (const key of keys) {\n\t\t\t\tif (key !== cacheName) await caches.delete(key)\n\t\t\t}\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim\n\t\t\tself.clients.claim()\n\t\t})\n\t)\n})\n\nself.addEventListener('fetch', event => {\n\tif (event.request.method !== 'GET' || event.request.headers.has('range')) return\n\n\tconst url = new URL(event.request.url)\n\n\t// Don't try to handle non http URIs, e.g. `data:`\n\tif (!url.protocol.startsWith('http')) return\n\n\t// Ignore server requests when developing locally.\n\tif (url.hostname === 'localhost') return\n\n\t// Always serve the static files and generated assets from the cache.\n\tif (url.host === self.location.host && cachedFiles.has(url.pathname)) {\n\t\tevent.respondWith(caches.match(event.request))\n\t\treturn\n\t}\n\n\t// Requests for `*/` should serve the `index.html` file.\n\tif (url.origin === self.origin && url.pathname.endsWith('/')) {\n\t\tevent.respondWith(caches.match('/index.html'))\n\t\treturn\n\t}\n\n\t// TODO what is this about?\n\tif (event.request.cache === 'only-if-cached') return\n\n\t// Note: caching all other requests might be a bad idea, if\n\t// you have certain data consistency requirements. Depending\n\t// on your application, you might prefer a cache-first approach,\n\t// instead of the network-first approach here.\n\tevent.respondWith(\n\t\tcaches\n\t\t\t.open(`offline${cacheName}`)\n\t\t\t.then(async cache => {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await fetch(event.request)\n\t\t\t\t\tcache.put(event.request, response.clone())\n\t\t\t\t\treturn response\n\t\t\t\t} catch (err) {\n\t\t\t\t\tconst response = await cache.match(event.request)\n\t\t\t\t\tif (response) return response\n\n\t\t\t\t\tthrow err\n\t\t\t\t}\n\t\t\t})\n\t)\n})\n"],"names":["cachedFiles","Set","cacheableFiles","self","addEventListener","event","waitUntil","caches","open","cacheName","then","cache","promises","prefetchCacheableUrls","map","async","url","URL","urlToPrefetch","request","Request","mode","response","fetch","put","Promise","all","addAll","skipWaiting","keys","key","delete","clients","claim","method","headers","has","protocol","startsWith","hostname","host","location","pathname","respondWith","match","origin","endsWith","clone","err"],"mappings":"ijBAcA,MAAMA,EAAc,IAAIC,IAAIC,GAE5BC,KAAKC,iBAAiB,UAAWC,IAChCA,EAAMC,UACLC,OACEC,KAAKC,GACLC,KAAKC,IACL,MAAMC,EAAWC,EAAsBC,IAAIC,MAAAA,IAC1C,MAAMC,EAAM,IAAIC,IAAIC,GAWdC,EAAU,IAAIC,QAAQJ,EAAK,CAAEK,KAAM,YACnCC,QAAiBC,MAAMJ,GAM7B,OAAOR,EAAMa,IAAIN,EAAeI,KAEjC,OAAOG,QAAQC,IAAI,CAClBf,EAAMgB,OAAOzB,MACVU,MAGJF,KAAK,KAELP,KAAKyB,mBAKTzB,KAAKC,iBAAiB,WAAYC,IACjCA,EAAMC,UACLC,OAAOsB,OAAOnB,KAAKK,MAAAA,IAElB,IAAK,MAAMe,KAAOD,EACbC,IAAQrB,SAAiBF,OAAOwB,OAAOD,GAG5C3B,KAAK6B,QAAQC,aAKhB9B,KAAKC,iBAAiB,QAASC,IAC9B,GAA6B,QAAzBA,EAAMc,QAAQe,QAAoB7B,EAAMc,QAAQgB,QAAQC,IAAI,SAAU,OAE1E,MAAMpB,EAAM,IAAIC,IAAIZ,EAAMc,QAAQH,KAG7BA,EAAIqB,SAASC,WAAW,SAGR,cAAjBtB,EAAIuB,WAGJvB,EAAIwB,OAASrC,KAAKsC,SAASD,MAAQxC,EAAYoC,IAAIpB,EAAI0B,UAC1DrC,EAAMsC,YAAYpC,OAAOqC,MAAMvC,EAAMc,UAKlCH,EAAI6B,SAAW1C,KAAK0C,QAAU7B,EAAI0B,SAASI,SAAS,KACvDzC,EAAMsC,YAAYpC,OAAOqC,MAAM,gBAKJ,mBAAxBvC,EAAMc,QAAQR,OAMlBN,EAAMsC,YACLpC,OACEC,KAAK,UAAUC,KACfC,KAAKK,MAAAA,IACL,IACC,MAAMO,QAAiBC,MAAMlB,EAAMc,SAEnC,OADAR,EAAMa,IAAInB,EAAMc,QAASG,EAASyB,SAC3BzB,EACN,MAAO0B,GACR,MAAM1B,QAAiBX,EAAMiC,MAAMvC,EAAMc,SACzC,GAAIG,EAAU,OAAOA,EAErB,MAAM0B"}